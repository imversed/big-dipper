"use strict";
/**
 * Copyright 2017-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Return `value` if its distance to `center` was scaled by `zoom`.
 *
 * e.g. zoomOut(100, 2, 50) -> 150
 * e.g. zoomOut(0, 2, 50) -> -50
 * e.g. zoomOut(100, 0.5, 50) -> 75
 * e.g. zoomOut(0, 0.5, 50) -> 25
 */
function zoomOut(value, zoom, center) {
    return center - (center - value) * zoom;
}
exports.zoomOut = zoomOut;
/**
 * This is the zoomOut method algebra-ed to solve for the `center` value
 * given the other three. The "target" is the return value of zoomOut.
 */
function getZoomOutCenter(value, zoom, target) {
    return (value * zoom - target) / (zoom - 1);
}
/**
 * Return possibly different zoomAmount and centerPoint values such that applying the zoom
 * to the scale respects the given min/max extents and values.
 */
function constrainedZoom(scale, zoomAmount, centerPoint, minDomainExtent, maxDomainExtent, minDomainValue, maxDomainValue) {
    zoomAmount = constrainZoomExtents(scale, zoomAmount, minDomainExtent, maxDomainExtent);
    return constrainZoomValues(scale, zoomAmount, centerPoint, minDomainValue, maxDomainValue);
}
exports.constrainedZoom = constrainedZoom;
function constrainZoomExtents(scale, zoomAmount, minDomainExtent, maxDomainExtent) {
    var extentIncreasing = zoomAmount > 1;
    var boundingDomainExtent = extentIncreasing ? maxDomainExtent : minDomainExtent;
    if (boundingDomainExtent == null) {
        return zoomAmount;
    }
    var _a = scale.getTransformationDomain(), scaleDomainMin = _a[0], scaleDomainMax = _a[1];
    var domainExtent = Math.abs(scaleDomainMax - scaleDomainMin);
    var compareF = extentIncreasing ? Math.min : Math.max;
    return compareF(zoomAmount, boundingDomainExtent / domainExtent);
}
exports.constrainZoomExtents = constrainZoomExtents;
/**
 * Modify zoomAmount and centerPoint such that a panzoom will stay inside
 * the bounds defined by minDomainValue and maxDomainValue.
 */
function constrainZoomValues(scale, zoomAmount, centerPoint, minDomainValue, maxDomainValue) {
    // when zooming in, we don't have to worry about overflowing domain
    if (zoomAmount <= 1) {
        return { centerPoint: centerPoint, zoomAmount: zoomAmount };
    }
    // if no constraints set, we're done
    if (minDomainValue == null && maxDomainValue == null) {
        return { centerPoint: centerPoint, zoomAmount: zoomAmount };
    }
    var rangeReversed = isRangeReversed(scale);
    var domainReversed = isDomainReversed(scale);
    var defaultDomainMin = domainReversed ? Infinity : -Infinity;
    var defaultDomainMax = domainReversed ? -Infinity : Infinity;
    minDomainValue = minDomainValue == null ? defaultDomainMin : minDomainValue;
    maxDomainValue = maxDomainValue == null ? defaultDomainMax : maxDomainValue;
    var _a = scale.getTransformationDomain(), scaleDomainMin = _a[0], scaleDomainMax = _a[1];
    var maxRange = scale.scaleTransformation(maxDomainValue);
    var currentMaxRange = scale.scaleTransformation(scaleDomainMax);
    var newMaxRange = zoomOut(currentMaxRange, zoomAmount, centerPoint);
    var minRange = scale.scaleTransformation(minDomainValue);
    var currentMinRange = scale.scaleTransformation(scaleDomainMin);
    var newMinRange = zoomOut(currentMinRange, zoomAmount, centerPoint);
    var minMaxLength = Math.abs(maxRange - minRange);
    var newRangeLength = Math.abs(newMaxRange - newMinRange);
    if (newRangeLength > minMaxLength) {
        // The new zoom simply won't fit. Instead just set the zoom amount to a full zoom out.
        var wantedZoomAmount = (maxRange - minRange) / (currentMaxRange - currentMinRange);
        if (wantedZoomAmount !== 1) {
            // only solve for centerPoint if wantedZoomAmount isn't 1 to prevent NaN.
            var wantedCenterPoint = getZoomOutCenter(currentMaxRange, wantedZoomAmount, maxRange);
            return {
                centerPoint: wantedCenterPoint,
                zoomAmount: wantedZoomAmount,
            };
        }
        else {
            // the centerPoint doesn't matter at all here but we must include it
            return {
                centerPoint: centerPoint,
                zoomAmount: wantedZoomAmount,
            };
        }
    }
    else {
        // the zoom does fit, but one end is outside. In this case just nudge the edge in
        if (newMaxRange > maxRange != rangeReversed) {
            // prevent out of bounds on max edge.
            return {
                centerPoint: getZoomOutCenter(currentMaxRange, zoomAmount, maxRange),
                zoomAmount: zoomAmount,
            };
        }
        else if (newMinRange < minRange != rangeReversed) {
            // prevent out of bounds on min edge.
            return {
                centerPoint: getZoomOutCenter(currentMinRange, zoomAmount, minRange),
                zoomAmount: zoomAmount,
            };
        }
        else {
            return { centerPoint: centerPoint, zoomAmount: zoomAmount };
        }
    }
}
exports.constrainZoomValues = constrainZoomValues;
/**
 * Returns a new translation value that respects domain min/max value
 * constraints.
 */
function constrainedTranslation(scale, translation, minDomainValue, maxDomainValue) {
    var _a = scale.getTransformationDomain(), scaleDomainMin = _a[0], scaleDomainMax = _a[1];
    var reversed = isRangeReversed(scale);
    if (translation > 0 !== reversed) {
        var bound = maxDomainValue;
        if (bound != null) {
            var currentMaxRange = scale.scaleTransformation(scaleDomainMax);
            var maxRange = scale.scaleTransformation(bound);
            translation = (reversed ? Math.max : Math.min)(currentMaxRange + translation, maxRange) - currentMaxRange;
        }
    }
    else {
        var bound = minDomainValue;
        if (bound != null) {
            var currentMinRange = scale.scaleTransformation(scaleDomainMin);
            var minRange = scale.scaleTransformation(bound);
            translation = (reversed ? Math.min : Math.max)(currentMinRange + translation, minRange) - currentMinRange;
        }
    }
    return translation;
}
exports.constrainedTranslation = constrainedTranslation;
/**
 * Returns true iff the scale.range[1] < scale.range[0].
 */
function isRangeReversed(scale) {
    var range = scale.range();
    return range[1] < range[0];
}
function isDomainReversed(scale) {
    var domain = scale.getTransformationDomain();
    return domain[1] < domain[0];
}
