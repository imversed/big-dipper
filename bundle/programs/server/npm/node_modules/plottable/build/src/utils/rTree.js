"use strict";
/**
 * Copyright 2017-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
var rTreeSplitStrategies_1 = require("./rTreeSplitStrategies");
/**
 * The maximum number of children in an r-tree node before we attempt to split.
 * This must be >= 2.
 */
var DEFAULT_MAX_NODE_CHILDREN = 5;
/**
 * There are several strategies for splitting nodes that contain overlapping
 * regions. By default we use `SplitStrategyLinear` which minimizes the change
 * in node bounding box area.
 */
var DEFAULT_SPLIT_STRATEGY = new rTreeSplitStrategies_1.SplitStrategyLinear();
/**
 * The return result of predicates used with `RTree.queryNodes`.
 *
 * The `PASS_AND_OVERWRITE` value will overwrite previous results
 * when the predicate finds a more optimal result.
 */
var QueryPredicateResult;
(function (QueryPredicateResult) {
    QueryPredicateResult[QueryPredicateResult["PASS"] = 0] = "PASS";
    QueryPredicateResult[QueryPredicateResult["FAIL"] = 1] = "FAIL";
    QueryPredicateResult[QueryPredicateResult["PASS_AND_OVERWRITE"] = 2] = "PASS_AND_OVERWRITE";
})(QueryPredicateResult = exports.QueryPredicateResult || (exports.QueryPredicateResult = {}));
/**
 * Creates a node predicate for use with `RTree.queryNodes`
 *
 * @param point - the query point
 * @param nearFn - an `IDistanceFunction` from the query point to the nearest
 * point on the node bounds
 * @param farFn - an `IDistanceFunction` from the query point to the farthest
 * point on the node bounds
 */
function createMinimizingNodePredicate(point, nearFn, farFn) {
    var nearestLeafDistance = Infinity;
    var nearestBranchDistance = Infinity;
    var farthestBranchDistance = Infinity;
    return function (node) {
        var near = nearFn(node.bounds, point);
        var far = farFn(node.bounds, point);
        // assumption: node.value indicates that parent is a leaf
        if (node.value != null) {
            if (near < nearestLeafDistance) {
                nearestLeafDistance = near;
                nearestBranchDistance = near;
                farthestBranchDistance = far;
                return QueryPredicateResult.PASS_AND_OVERWRITE;
            }
            else if (near === nearestLeafDistance) {
                return QueryPredicateResult.PASS;
            }
            else {
                return QueryPredicateResult.FAIL;
            }
        }
        else {
            if (near > farthestBranchDistance) {
                return QueryPredicateResult.FAIL;
            }
            else {
                nearestBranchDistance = Math.min(near, nearestBranchDistance);
                farthestBranchDistance = Math.max(far, farthestBranchDistance);
                return QueryPredicateResult.PASS;
            }
        }
    };
}
exports.createMinimizingNodePredicate = createMinimizingNodePredicate;
/**
 * Create a `Array.sort` function from a query point and a distance function.
 */
function createNodeSort(point, distanceFn) {
    return function (a, b) {
        return distanceFn(b.bounds, point) - distanceFn(a.bounds, point);
    };
}
exports.createNodeSort = createNodeSort;
/**
 * R-Tree is a multidimensional spatial region tree. It stores entries that have
 * arbitrarily overlapping bounding boxes and supports efficient point and
 * bounding box overlap queries.
 *
 * Average search time complexity is O(log_M(N)) where M = max children per node
 * and N is number of values stored in tree.
 *
 * It is similar in purpose to a quadtree except quadtrees can only store a
 * single point per entry. Also, the space-partitioning structure of quadtrees
 * provides guarantees that any given value has no neighbors closer than its
 * node's bounds, whereas r-trees provide no such guarantees.
 */
var RTree = /** @class */ (function () {
    function RTree(maxNodeChildren, splitStrategy) {
        if (maxNodeChildren === void 0) { maxNodeChildren = DEFAULT_MAX_NODE_CHILDREN; }
        if (splitStrategy === void 0) { splitStrategy = DEFAULT_SPLIT_STRATEGY; }
        this.maxNodeChildren = maxNodeChildren;
        this.splitStrategy = splitStrategy;
        this.root = new RTreeNode(true);
        this.size = 0;
    }
    RTree.prototype.getRoot = function () {
        return this.root;
    };
    RTree.prototype.clear = function () {
        this.root = new RTreeNode(true);
        this.size = 0;
    };
    RTree.prototype.insert = function (bounds, value) {
        var node = this.root;
        // Choose subtree until we find a leaf
        while (!node.leaf) {
            node = node.subtree(bounds);
        }
        // Insert new value node into leaf node
        var valueNode = RTreeNode.valueNode(bounds, value);
        node.insert(valueNode);
        this.size += 1;
        // While node overflows, split and walk up
        while (node.overflow(this.maxNodeChildren)) {
            node = node.split(this.splitStrategy);
            if (node.parent == null) {
                this.root = node;
            }
        }
        return valueNode;
    };
    RTree.prototype.locate = function (xy) {
        return this.query(function (b) { return b.contains(xy); });
    };
    /**
     * Returns an array of `T` values that are the "nearest" to the query point.
     *
     * Nearness is measured as the absolute distance from the query point to the
     * nearest edge of the node bounds. If the node bounds contains the query
     * point, the distance is 0.
     */
    RTree.prototype.locateNearest = function (xy) {
        var predicate = createMinimizingNodePredicate(xy, RTreeBounds.distanceSquaredToNearEdge, RTreeBounds.distanceSquaredToFarEdge);
        var nodes = this.queryNodes(predicate);
        return nodes.map(function (node) { return node.value; });
    };
    /**
     * Returns an array of `T` values that are the "nearest" to the query point.
     *
     * Nearness is measured as the 1-dimensional absolute distance from the
     * query's x point to the nearest edge of the node bounds. If the node
     * bounds contains the query point, the distance is 0.
     *
     * The results are sorted by y-coordinate nearness.
     */
    RTree.prototype.locateNearestX = function (xy) {
        var predicate = createMinimizingNodePredicate(xy, RTreeBounds.absoluteDistanceToNearEdgeX, RTreeBounds.absoluteDistanceToFarEdgeX);
        var nodes = this.queryNodes(predicate);
        nodes.sort(createNodeSort(xy, RTreeBounds.absoluteDistanceToNearEdgeY));
        return nodes.map(function (node) { return node.value; });
    };
    /**
     * Returns an array of `T` values that are the "nearest" to the query point.
     *
     * Nearness is measured as the 1-dimensional absolute distance from the
     * query's y point to the nearest edge of the node bounds. If the node
     * bounds contains the query point, the distance is 0.
     *
     * The results are sorted by x-coordinate nearness.
     */
    RTree.prototype.locateNearestY = function (xy) {
        var predicate = createMinimizingNodePredicate(xy, RTreeBounds.absoluteDistanceToNearEdgeY, RTreeBounds.absoluteDistanceToFarEdgeY);
        var nodes = this.queryNodes(predicate);
        nodes.sort(createNodeSort(xy, RTreeBounds.absoluteDistanceToNearEdgeX));
        return nodes.map(function (node) { return node.value; });
    };
    RTree.prototype.intersect = function (bounds) {
        return this.query(function (b) { return RTreeBounds.isBoundsOverlapBounds(b, bounds); });
    };
    RTree.prototype.intersectX = function (bounds) {
        return this.query(function (b) { return RTreeBounds.isBoundsOverlapX(b, bounds); });
    };
    RTree.prototype.intersectY = function (bounds) {
        return this.query(function (b) { return RTreeBounds.isBoundsOverlapY(b, bounds); });
    };
    RTree.prototype.query = function (predicate) {
        var results = [];
        if (this.root.bounds != null && !predicate(this.root.bounds)) {
            return results;
        }
        var candidates = [this.root];
        while (candidates.length > 0) {
            var candidate = candidates.shift();
            for (var i = 0; i < candidate.entries.length; i++) {
                var entry = candidate.entries[i];
                if (predicate(entry.bounds)) {
                    if (candidate.leaf) {
                        results.push(entry.value);
                    }
                    else {
                        candidates.push(entry);
                    }
                }
            }
        }
        return results;
    };
    RTree.prototype.queryNodes = function (predicate) {
        var results = [];
        if (this.root.bounds != null && predicate(this.root) === QueryPredicateResult.FAIL) {
            return results;
        }
        var candidates = [this.root];
        while (candidates.length > 0) {
            var candidate = candidates.shift();
            for (var i = 0; i < candidate.entries.length; i++) {
                var entry = candidate.entries[i];
                var p = predicate(entry);
                if (p === QueryPredicateResult.PASS_AND_OVERWRITE) {
                    results = [];
                }
                if (p === QueryPredicateResult.PASS || p === QueryPredicateResult.PASS_AND_OVERWRITE) {
                    if (candidate.leaf) {
                        results.push(entry);
                    }
                    else {
                        candidates.push(entry);
                    }
                }
            }
        }
        return results;
    };
    return RTree;
}());
exports.RTree = RTree;
var RTreeNode = /** @class */ (function () {
    function RTreeNode(leaf) {
        this.leaf = leaf;
        this.bounds = null;
        this.entries = [];
        this.parent = null;
        this.value = null;
    }
    RTreeNode.valueNode = function (bounds, value) {
        var node = new RTreeNode(true);
        node.bounds = bounds;
        node.value = value;
        return node;
    };
    /**
     * Returns `true` iff this node has more children than the `maxNodeChildren`
     * parameter.
     */
    RTreeNode.prototype.overflow = function (maxNodeChildren) {
        return this.entries.length > maxNodeChildren;
    };
    /**
     * Inserts a child node and updates the ancestry bounds.
     */
    RTreeNode.prototype.insert = function (node) {
        this.entries.push(node);
        node.parent = this;
        // Update ancestor bounds
        var ancestor = this;
        while (ancestor != null) {
            ancestor.bounds = RTreeBounds.unionAll([ancestor.bounds, node.bounds]);
            ancestor = ancestor.parent;
        }
        return this;
    };
    /**
     * Removes a child node and updates the ancestry bounds.
     *
     * If the node argument is not a child, do nothing.
     */
    RTreeNode.prototype.remove = function (node) {
        var i = this.entries.indexOf(node);
        if (i >= 0) {
            this.entries.splice(i, 1);
            // Update ancestor bounds
            var ancestor = this;
            while (ancestor != null) {
                ancestor.bounds = RTreeBounds.unionAll(ancestor.entries.map(function (e) { return e.bounds; }));
                ancestor = ancestor.parent;
            }
        }
        return this;
    };
    /**
     * Chooses an node from then entries that minimizes the area difference that
     * adding the bounds the each entry would cause.
     */
    RTreeNode.prototype.subtree = function (bounds) {
        var minDiff = Infinity;
        var minEntry = null;
        // choose entry for which the addition least increases the entry's area
        for (var i = 0; i < this.entries.length; i++) {
            var entry = this.entries[i];
            var diffArea = entry.unionAreaDifference(bounds);
            if (diffArea < minDiff || (
            // break ties to node with fewest children
            diffArea === minDiff &&
                minEntry != null &&
                entry.entries.length < minEntry.entries.length)) {
                minEntry = entry;
            }
        }
        return minEntry;
    };
    /**
     * Splits this node by creating two new nodes and dividing the this node's
     * children between them. This node is removed from its parent and the two
     * new nodes are added.
     *
     * If this node is the root, a new parent node is created.
     *
     * Returns the parent node.
     */
    RTreeNode.prototype.split = function (strategy) {
        // Remove self from parent.
        if (this.parent != null) {
            this.parent.remove(this);
        }
        // Create children from split
        var children = [
            new RTreeNode(this.leaf),
            new RTreeNode(this.leaf),
        ];
        strategy.split(this.entries, children);
        // Add new nodes to parent
        // If root, create new non-leaf node as parent.
        var parent = this.parent != null ? this.parent : new RTreeNode(false);
        parent.insert(children[0]);
        parent.insert(children[1]);
        // Always make the parent a non-leaf after split
        parent.leaf = false;
        return parent;
    };
    /**
     * Returns the difference in area that adding an entry `bounds` to the node
     * would cause.
     */
    RTreeNode.prototype.unionAreaDifference = function (bounds) {
        return Math.abs(RTreeBounds.union(this.bounds, bounds).area() - this.bounds.area());
    };
    /**
     * Returns the depth from this node to the deepest leaf descendant.
     */
    RTreeNode.prototype.maxDepth = function () {
        if (this.leaf)
            return 1;
        return 1 + this.entries.map(function (e) { return e.maxDepth(); }).reduce(function (a, b) { return Math.max(a, b); });
    };
    return RTreeNode;
}());
exports.RTreeNode = RTreeNode;
var RTreeBounds = /** @class */ (function () {
    function RTreeBounds(xl, yl, xh, yh) {
        this.xl = xl;
        this.yl = yl;
        this.xh = xh;
        this.yh = yh;
        this.width = this.xh - this.xl;
        this.height = this.yh - this.yl;
    }
    RTreeBounds.xywh = function (x, y, w, h) {
        return new RTreeBounds(x, y, x + w, y + h);
    };
    RTreeBounds.entityBounds = function (bounds) {
        return new RTreeBounds(bounds.x, bounds.y, bounds.x + bounds.width, bounds.y + bounds.height);
    };
    RTreeBounds.bounds = function (bounds) {
        return RTreeBounds.pointPair(bounds.topLeft, bounds.bottomRight);
    };
    RTreeBounds.pointPair = function (p0, p1) {
        return new RTreeBounds(Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y));
    };
    RTreeBounds.points = function (points) {
        if (points.length < 2) {
            throw new Error("need at least 2 points to create bounds");
        }
        var xs = points.map(function (p) { return p.x; });
        var ys = points.map(function (p) { return p.y; });
        return new RTreeBounds(xs.reduce(function (a, b) { return Math.min(a, b); }), ys.reduce(function (a, b) { return Math.min(a, b); }), xs.reduce(function (a, b) { return Math.max(a, b); }), ys.reduce(function (a, b) { return Math.max(a, b); }));
    };
    RTreeBounds.union = function (b0, b1) {
        return new RTreeBounds(Math.min(b0.xl, b1.xl), Math.min(b0.yl, b1.yl), Math.max(b0.xh, b1.xh), Math.max(b0.yh, b1.yh));
    };
    RTreeBounds.unionAll = function (bounds) {
        bounds = bounds.filter(function (b) { return b != null; });
        if (bounds.length === 0) {
            return null;
        }
        return bounds.reduce(function (b0, b1) { return RTreeBounds.union(b0, b1); });
    };
    /**
     * Returns true if `a` overlaps `b` in the x and y axes.
     *
     * Touching counts as overlap.
     */
    RTreeBounds.isBoundsOverlapBounds = function (a, b) {
        return RTreeBounds.isBoundsOverlapX(a, b) && RTreeBounds.isBoundsOverlapY(a, b);
    };
    /**
     * Returns true if `a` overlaps `b` in the x axis only.
     *
     * Touching counts as overlap.
     */
    RTreeBounds.isBoundsOverlapX = function (a, b) {
        return !(a.xh < b.xl) && !(a.xl > b.xh);
    };
    /**
     * Returns true if `a` overlaps `b` in the y axis only.
     *
     * Touching counts as overlap.
     */
    RTreeBounds.isBoundsOverlapY = function (a, b) {
        return !(a.yh < b.yl) && !(a.yl > b.yh);
    };
    /**
     * Returns the orthogonal absolute distance in the x-dimension from point
     * `p` to the nearest edge of `bounds`.
     *
     * If `p.x` is inside the bounds returns `0`.
     */
    RTreeBounds.absoluteDistanceToNearEdgeX = function (bounds, p) {
        var half = bounds.width / 2;
        var mid = bounds.xl + half;
        return Math.max(Math.abs(p.x - mid) - half, 0);
    };
    /**
     * Returns the orthogonal absolute distance in the y-dimension from point
     * `p` to the nearest edge of `bounds`.
     *
     * If `p.y` is inside the bounds returns `0`.
     */
    RTreeBounds.absoluteDistanceToNearEdgeY = function (bounds, p) {
        var half = bounds.height / 2;
        var mid = bounds.yl + half;
        return Math.max(Math.abs(p.y - mid) - half, 0);
    };
    /**
     * Returns the orthogonal absolute distance in the x-dimension from point
     * `p` to the farthest edge of `bounds`.
     *
     * If `p.x` is inside the bounds returns `0`.
     */
    RTreeBounds.absoluteDistanceToFarEdgeX = function (bounds, p) {
        var near = RTreeBounds.absoluteDistanceToNearEdgeX(bounds, p);
        return near === 0 ? 0 : near + bounds.width;
    };
    /**
     * Returns the orthogonal absolute distance in the y-dimension from point
     * `p` to the farthest edge of `bounds`.
     *
     * If `p.y` is inside the bounds returns `0`.
     */
    RTreeBounds.absoluteDistanceToFarEdgeY = function (bounds, p) {
        var near = RTreeBounds.absoluteDistanceToNearEdgeY(bounds, p);
        return near === 0 ? 0 : near + bounds.height;
    };
    /**
     * Returns the distance squared from `p` to the nearest edge of `bounds`. If
     * the point touches or is inside the bounds, returns `0`;
     *
     * https://gamedev.stackexchange.com/questions/44483/how-do-i-calculate-distance-between-a-point-and-an-axis-aligned-rectangle
     */
    RTreeBounds.distanceSquaredToNearEdge = function (bounds, p) {
        var dx = RTreeBounds.absoluteDistanceToNearEdgeX(bounds, p);
        var dy = RTreeBounds.absoluteDistanceToNearEdgeY(bounds, p);
        return dx * dx + dy * dy;
    };
    RTreeBounds.distanceSquaredToFarEdge = function (bounds, p) {
        var dx = RTreeBounds.absoluteDistanceToFarEdgeX(bounds, p);
        var dy = RTreeBounds.absoluteDistanceToFarEdgeY(bounds, p);
        return dx * dx + dy * dy;
    };
    RTreeBounds.prototype.area = function () {
        if (this.areaCached == null) {
            this.areaCached = (this.xh - this.xl) * (this.yh - this.yl);
        }
        return this.areaCached;
    };
    RTreeBounds.prototype.contains = function (xy) {
        return this.xl <= xy.x && this.xh >= xy.x && this.yl <= xy.y && this.yh >= xy.y;
    };
    return RTreeBounds;
}());
exports.RTreeBounds = RTreeBounds;
