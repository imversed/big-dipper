"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var d3 = require("d3");
var Animators = require("../animators");
var index_1 = require("../memoize/index");
var Utils = require("../utils");
var areaPlot_1 = require("./areaPlot");
var plot_1 = require("./plot");
var StackedArea = /** @class */ (function (_super) {
    tslib_1.__extends(StackedArea, _super);
    /**
     * @constructor
     */
    function StackedArea() {
        var _this = _super.call(this) || this;
        _this._stackingResult = index_1.memThunk(function () { return _this.datasets(); }, function () { return _this.x().accessor; }, function () { return _this.y().accessor; }, function () { return _this._stackingOrder; }, function (datasets, keyAccessor, valueAccessor, stackingOrder) {
            return Utils.Stacking.stack(datasets, keyAccessor, valueAccessor, stackingOrder);
        });
        _this._stackedExtent = index_1.memThunk(_this._stackingResult, function () { return _this.x().accessor; }, function () { return _this._filterForProperty("y"); }, function (stackingResult, keyAccessor, filter) {
            return Utils.Stacking.stackedExtent(stackingResult, keyAccessor, filter);
        });
        _this._baselineValue = 0;
        _this._stackingOrder = "bottomup";
        _this.addClass("stacked-area-plot");
        _this._baselineValueProvider = function () { return [_this._baselineValue]; };
        _this.croppedRenderingEnabled(false);
        return _this;
    }
    StackedArea.prototype.croppedRenderingEnabled = function (croppedRendering) {
        if (croppedRendering == null) {
            return _super.prototype.croppedRenderingEnabled.call(this);
        }
        if (croppedRendering) {
            // HACKHACK #3032: cropped rendering doesn't currently work correctly on StackedArea
            Utils.Window.warn("Warning: Stacked Area Plot does not support cropped rendering.");
            return this;
        }
        return _super.prototype.croppedRenderingEnabled.call(this, croppedRendering);
    };
    StackedArea.prototype._getAnimator = function (key) {
        return new Animators.Null();
    };
    StackedArea.prototype._setup = function () {
        _super.prototype._setup.call(this);
        this._baseline = this._renderArea.append("line").classed("baseline", true);
    };
    StackedArea.prototype.x = function (x, xScale) {
        if (x == null) {
            return _super.prototype.x.call(this);
        }
        if (xScale == null) {
            _super.prototype.x.call(this, x);
        }
        else {
            _super.prototype.x.call(this, x, xScale);
        }
        this._checkSameDomain();
        return this;
    };
    StackedArea.prototype.y = function (y, yScale) {
        if (y == null) {
            return _super.prototype.y.call(this);
        }
        if (yScale == null) {
            _super.prototype.y.call(this, y);
        }
        else {
            _super.prototype.y.call(this, y, yScale);
        }
        this._checkSameDomain();
        return this;
    };
    /**
     * Gets the offset of the y value corresponding to an x value of a given dataset. This allows other plots to plot
     * points corresponding to their stacked value in the graph.
     * @param dataset The dataset from which to retrieve the y value offset
     * @param x The x value corresponding to the y-value of interest.
     */
    StackedArea.prototype.yOffset = function (dataset, x) {
        var stackingResult = this._stackingResult();
        if (stackingResult == null) {
            return undefined;
        }
        var datasetStackingResult = stackingResult.get(dataset);
        if (datasetStackingResult == null) {
            return undefined;
        }
        var result = datasetStackingResult.get(String(x));
        if (result == null) {
            return undefined;
        }
        return result.offset;
    };
    StackedArea.prototype.stackingOrder = function (stackingOrder) {
        if (stackingOrder == null) {
            return this._stackingOrder;
        }
        this._stackingOrder = stackingOrder;
        this._onDatasetUpdate();
        return this;
    };
    StackedArea.prototype.downsamplingEnabled = function (downsampling) {
        if (downsampling == null) {
            return _super.prototype.downsamplingEnabled.call(this);
        }
        Utils.Window.warn("Warning: Stacked Area Plot does not support downsampling");
        return this;
    };
    StackedArea.prototype._additionalPaint = function () {
        var scaledBaseline = this.y().scale.scale(this._baselineValue);
        var baselineAttr = {
            x1: 0,
            y1: scaledBaseline,
            x2: this.width(),
            y2: scaledBaseline,
        };
        this._getAnimator("baseline").animate(this._baseline, baselineAttr);
    };
    StackedArea.prototype._updateYScale = function () {
        var yBinding = this.y();
        var scale = (yBinding && yBinding.scale);
        if (scale == null) {
            return;
        }
        scale.addPaddingExceptionsProvider(this._baselineValueProvider);
        scale.addIncludedValuesProvider(this._baselineValueProvider);
    };
    StackedArea.prototype._onDatasetUpdate = function () {
        this._checkSameDomain();
        _super.prototype._onDatasetUpdate.call(this);
        return this;
    };
    StackedArea.prototype.getExtentsForProperty = function (attr) {
        var primaryAttr = "y";
        if (attr === primaryAttr) {
            return [this._stackedExtent()];
        }
        else {
            return _super.prototype.getExtentsForProperty.call(this, attr);
        }
    };
    StackedArea.prototype._checkSameDomain = function () {
        if (!this._projectorsReady()) {
            return;
        }
        var datasets = this.datasets();
        var keyAccessor = this.x().accessor;
        var keySets = datasets.map(function (dataset) {
            return d3.set(dataset.data().map(function (datum, i) { return Utils.Stacking.normalizeKey(keyAccessor(datum, i, dataset)); })).values();
        });
        var domainKeys = StackedArea._domainKeys(datasets, keyAccessor);
        if (keySets.some(function (keySet) { return keySet.length !== domainKeys.length; })) {
            Utils.Window.warn("the domains across the datasets are not the same. Plot may produce unintended behavior.");
        }
    };
    /**
     * Given an array of Datasets and the accessor function for the key, computes the
     * set reunion (no duplicates) of the domain of each Dataset. The keys are stringified
     * before being returned.
     *
     * @param {Dataset[]} datasets The Datasets for which we extract the domain keys
     * @param {Accessor<any>} keyAccessor The accessor for the key of the data
     * @return {string[]} An array of stringified keys
     */
    StackedArea._domainKeys = function (datasets, keyAccessor) {
        var domainKeys = d3.set();
        datasets.forEach(function (dataset) {
            var data = dataset.data();
            var dataLen = data.length;
            for (var index = 0; index < dataLen; index++) {
                var datum = data[index];
                domainKeys.add(keyAccessor(datum, index, dataset));
            }
        });
        return domainKeys.values();
    };
    StackedArea.prototype._coordinateProjectors = function () {
        var _this = this;
        var xProjector = plot_1.Plot._scaledAccessor(this.x());
        var yAccessor = this.y().accessor;
        var xAccessor = this.x().accessor;
        var normalizedXAccessor = function (datum, index, dataset) {
            return Utils.Stacking.normalizeKey(xAccessor(datum, index, dataset));
        };
        var stackingResult = this._stackingResult();
        var stackYProjector = function (d, i, dataset) {
            var y = +yAccessor(d, i, dataset);
            var offset = stackingResult.get(dataset).get(normalizedXAccessor(d, i, dataset)).offset;
            return _this.y().scale.scale(y + offset);
        };
        var stackY0Projector = function (d, i, dataset) {
            var offset = stackingResult.get(dataset).get(normalizedXAccessor(d, i, dataset)).offset;
            return _this.y().scale.scale(offset);
        };
        return [
            xProjector,
            stackYProjector,
            stackY0Projector,
        ];
    };
    StackedArea.prototype._propertyProjectors = function () {
        var propertyToProjectors = _super.prototype._propertyProjectors.call(this);
        var _a = this._coordinateProjectors(), xProjector = _a[0], stackYProjector = _a[1], stackY0Projector = _a[2];
        propertyToProjectors["d"] = this._constructAreaProjector(xProjector, stackYProjector, stackY0Projector);
        return propertyToProjectors;
    };
    StackedArea.prototype._pixelPoint = function (datum, index, dataset) {
        var pixelPoint = _super.prototype._pixelPoint.call(this, datum, index, dataset);
        var xValue = this.x().accessor(datum, index, dataset);
        var yValue = this.y().accessor(datum, index, dataset);
        var scaledYValue = this.y().scale.scale(+yValue + this._stackingResult().get(dataset).get(Utils.Stacking.normalizeKey(xValue)).offset);
        return { x: pixelPoint.x, y: scaledYValue };
    };
    return StackedArea;
}(areaPlot_1.Area));
exports.StackedArea = StackedArea;
