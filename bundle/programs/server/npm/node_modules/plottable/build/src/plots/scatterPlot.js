"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Typesettable = require("typesettable");
var Formatters = require("../core/formatters");
var SymbolFactories = require("../core/symbolFactories");
var drawer_1 = require("../drawers/drawer");
var symbolDrawer_1 = require("../drawers/symbolDrawer");
var Animators = require("../animators");
var label_1 = require("../components/label");
var Drawers = require("../drawers");
var Scales = require("../scales");
var Utils = require("../utils");
var Plots = require("./");
var plot_1 = require("./plot");
var xyPlot_1 = require("./xyPlot");
var Scatter = /** @class */ (function (_super) {
    tslib_1.__extends(Scatter, _super);
    /**
     * A Scatter Plot draws a symbol at each data point.
     *
     * @constructor
     */
    function Scatter() {
        var _this = _super.call(this) || this;
        _this._labelFormatter = Formatters.identity();
        _this._labelFontSize = label_1.Label._DEFAULT_FONT_SIZE_PX;
        _this._labelsEnabled = false;
        _this.addClass("scatter-plot");
        var animator = new Animators.Easing();
        animator.startDelay(5);
        animator.stepDuration(250);
        animator.maxTotalDuration(plot_1.Plot._ANIMATION_MAX_DURATION);
        _this.animator(Plots.Animator.MAIN, animator);
        _this.attr("opacity", 0.6);
        _this.attr("fill", new Scales.Color().range()[0]);
        _this.size(6);
        var circleSymbolFactory = SymbolFactories.circle();
        _this.symbol(function () { return circleSymbolFactory; });
        _this._labelConfig = new Utils.Map();
        return _this;
    }
    Scatter.prototype._buildLightweightPlotEntities = function (datasets) {
        var _this = this;
        var lightweightPlotEntities = _super.prototype._buildLightweightPlotEntities.call(this, datasets);
        return lightweightPlotEntities.map(function (lightweightPlotEntity) {
            var diameter = plot_1.Plot._scaledAccessor(_this.size())(lightweightPlotEntity.datum, lightweightPlotEntity.index, lightweightPlotEntity.dataset);
            lightweightPlotEntity.diameter = diameter;
            return lightweightPlotEntity;
        });
    };
    Scatter.prototype._createDrawer = function (dataset) {
        var _this = this;
        return new drawer_1.ProxyDrawer(function () { return new symbolDrawer_1.SymbolSVGDrawer(); }, function (ctx) {
            return new Drawers.CanvasDrawer(ctx, symbolDrawer_1.makeSymbolCanvasDrawStep(dataset, function () { return plot_1.Plot._scaledAccessor(_this.symbol()); }, function () { return plot_1.Plot._scaledAccessor(_this.size()); }));
        });
    };
    Scatter.prototype.size = function (size, scale) {
        if (size == null) {
            return this._propertyBindings.get(Scatter._SIZE_KEY);
        }
        this._bindProperty(Scatter._SIZE_KEY, size, scale);
        this.render();
        return this;
    };
    Scatter.prototype.symbol = function (symbol) {
        if (symbol == null) {
            return this._propertyBindings.get(Scatter._SYMBOL_KEY);
        }
        this._propertyBindings.set(Scatter._SYMBOL_KEY, { accessor: symbol });
        this.render();
        return this;
    };
    Scatter.prototype._generateDrawSteps = function () {
        var drawSteps = [];
        if (this._animateOnNextRender()) {
            var attrToProjector = this._getAttrToProjector();
            var symbolProjector_1 = plot_1.Plot._scaledAccessor(this.symbol());
            attrToProjector["d"] = function (datum, index, dataset) { return symbolProjector_1(datum, index, dataset)(0)(null); };
            drawSteps.push({ attrToProjector: attrToProjector, animator: this._getAnimator(Plots.Animator.RESET) });
        }
        drawSteps.push({
            attrToProjector: this._getAttrToProjector(),
            animator: this._getAnimator(Plots.Animator.MAIN),
        });
        return drawSteps;
    };
    Scatter.prototype._propertyProjectors = function () {
        var propertyToProjectors = _super.prototype._propertyProjectors.call(this);
        var xProjector = plot_1.Plot._scaledAccessor(this.x());
        var yProjector = plot_1.Plot._scaledAccessor(this.y());
        propertyToProjectors["x"] = xProjector;
        propertyToProjectors["y"] = yProjector;
        propertyToProjectors["transform"] = function (datum, index, dataset) {
            return "translate(" + xProjector(datum, index, dataset) + "," + yProjector(datum, index, dataset) + ")";
        };
        propertyToProjectors["d"] = this._constructSymbolGenerator();
        return propertyToProjectors;
    };
    Scatter.prototype._constructSymbolGenerator = function () {
        var symbolProjector = plot_1.Plot._scaledAccessor(this.symbol());
        var sizeProjector = plot_1.Plot._scaledAccessor(this.size());
        return function (datum, index, dataset) {
            return symbolProjector(datum, index, dataset)(sizeProjector(datum, index, dataset))(null);
        };
    };
    Scatter.prototype._entityBounds = function (entity) {
        return {
            x: entity.position.x - entity.diameter / 2,
            y: entity.position.y - entity.diameter / 2,
            width: entity.diameter,
            height: entity.diameter,
        };
    };
    Scatter.prototype._entityVisibleOnPlot = function (entity, bounds) {
        var xRange = { min: bounds.topLeft.x, max: bounds.bottomRight.x };
        var yRange = { min: bounds.topLeft.y, max: bounds.bottomRight.y };
        var translatedBbox = this._entityBounds(entity);
        return Utils.DOM.intersectsBBox(xRange, yRange, translatedBbox);
    };
    /**
     * Gets the Entities at a particular Point.
     *
     * @param {Point} p
     * @returns {PlotEntity[]}
     */
    Scatter.prototype.entitiesAt = function (p) {
        var xProjector = plot_1.Plot._scaledAccessor(this.x());
        var yProjector = plot_1.Plot._scaledAccessor(this.y());
        var sizeProjector = plot_1.Plot._scaledAccessor(this.size());
        return this.entities().filter(function (entity) {
            var datum = entity.datum;
            var index = entity.index;
            var dataset = entity.dataset;
            var x = xProjector(datum, index, dataset);
            var y = yProjector(datum, index, dataset);
            var size = sizeProjector(datum, index, dataset);
            return x - size / 2 <= p.x && p.x <= x + size / 2 && y - size / 2 <= p.y && p.y <= y + size / 2;
        });
    };
    Scatter.prototype.labelsEnabled = function (enabled) {
        if (enabled == null) {
            return this._labelsEnabled;
        }
        else {
            this._labelsEnabled = enabled;
            this._clearAttrToProjectorCache();
            this.render();
            return this;
        }
    };
    Scatter.prototype.labelFontSize = function (fontSize) {
        var _this = this;
        if (fontSize == null) {
            return this._labelFontSize;
        }
        else {
            this.invalidateCache();
            this._labelFontSize = fontSize;
            this._labelConfig.forEach(function (_a) {
                var labelArea = _a.labelArea;
                labelArea.attr("class", null)
                    .classed(Scatter._LABEL_AREA_CLASS, true)
                    .classed("label-" + _this._labelFontSize, true);
            });
            return this.render();
        }
    };
    Scatter.prototype.invalidateCache = function () {
        var _this = this;
        _super.prototype.invalidateCache.call(this);
        this.datasets().forEach(function (dataset) {
            var labelConfig = _this._labelConfig.get(dataset);
            if (labelConfig != null) {
                labelConfig.measurer.reset();
            }
        });
    };
    Scatter.prototype._createNodesForDataset = function (dataset) {
        var drawer = _super.prototype._createNodesForDataset.call(this, dataset);
        var labelArea = this._renderArea.append("g")
            .classed(Scatter._LABEL_AREA_CLASS, true)
            .classed("label-" + this._labelFontSize, true);
        var context = new Typesettable.SvgContext(labelArea.node());
        var measurer = new Typesettable.CacheMeasurer(context);
        var writer = new Typesettable.Writer(measurer, context);
        this._labelConfig.set(dataset, { labelArea: labelArea, measurer: measurer, writer: writer });
        return drawer;
    };
    Scatter.prototype._removeDatasetNodes = function (dataset) {
        _super.prototype._removeDatasetNodes.call(this, dataset);
        var labelConfig = this._labelConfig.get(dataset);
        if (labelConfig != null) {
            labelConfig.labelArea.remove();
            this._labelConfig.delete(dataset);
        }
    };
    Scatter.prototype._additionalPaint = function (time) {
        var _this = this;
        this.datasets().forEach(function (dataset) { return _this._labelConfig.get(dataset).labelArea.selectAll("g").remove(); });
        if (this._labelsEnabled) {
            Utils.Window.setTimeout(function () { return _this._drawLabels(); }, time);
        }
    };
    Scatter.prototype._drawLabels = function () {
        var _this = this;
        var dataToDraw = this._getDataToDraw();
        var attrToProjector = this._getAttrToProjector();
        this.datasets().forEach(function (dataset) {
            var data = dataToDraw.get(dataset);
            var dataLen = data.length;
            for (var index = 0; index < dataLen; index++) {
                var datum = data[index];
                if (datum == null) {
                    continue;
                }
                _this._drawLabel(datum, index, dataset, attrToProjector);
            }
        });
    };
    Scatter.prototype._drawLabel = function (datum, index, dataset, attrToProjector) {
        if (datum.label == null) {
            return;
        }
        var _a = this._labelConfig.get(dataset), labelArea = _a.labelArea, measurer = _a.measurer, writer = _a.writer;
        var scatterCoordinates = { x: attrToProjector["x"](datum, index, dataset), y: attrToProjector["y"](datum, index, dataset) };
        var sizeProjector = plot_1.Plot._scaledAccessor(this.size());
        var diameter = sizeProjector(datum, index, dataset);
        var label = this._labelFormatter(datum.label, datum, index, dataset);
        var measurement = measurer.measure(label);
        var _b = this._calculateLabelProperties(scatterCoordinates, diameter, measurement), containerDimensions = _b.containerDimensions, labelContainerOrigin = _b.labelContainerOrigin, labelOrigin = _b.labelOrigin, alignment = _b.alignment;
        var labelContainer = this._createLabelContainer(labelArea, labelContainerOrigin, labelOrigin, measurement);
        var writeOptions = { xAlign: alignment.x, yAlign: alignment.y };
        writer.write(label, containerDimensions.width, containerDimensions.height, writeOptions, labelContainer.node());
    };
    Scatter.prototype._calculateLabelProperties = function (pointCoordinates, diameter, measurement) {
        // If diameter is smaller than font size, put label above
        var labelShift = diameter < measurement.height ? diameter / 2 + Scatter._LABEL_MARGIN_FROM_BUBBLE : 0;
        return {
            containerDimensions: {
                width: measurement.width,
                height: measurement.height,
            },
            labelContainerOrigin: {
                x: pointCoordinates.x - measurement.width / 2,
                y: pointCoordinates.y - measurement.height / 2 + labelShift,
            },
            labelOrigin: {
                x: pointCoordinates.x,
                y: pointCoordinates.y,
            },
            alignment: {
                x: "center",
                y: "center",
            },
        };
    };
    Scatter.prototype._createLabelContainer = function (labelArea, labelContainerOrigin, labelOrigin, measurement) {
        var labelContainer = labelArea.append("g")
            .attr("transform", "translate(" + labelContainerOrigin.x + ", " + labelContainerOrigin.y + ")");
        labelContainer.classed("on-bar-label", true);
        return labelContainer;
    };
    Scatter._SIZE_KEY = "size";
    Scatter._SYMBOL_KEY = "symbol";
    // label stuff
    Scatter._LABEL_AREA_CLASS = "scatter-label-text-area";
    Scatter._LABEL_MARGIN_FROM_BUBBLE = 15;
    return Scatter;
}(xyPlot_1.XYPlot));
exports.Scatter = Scatter;
