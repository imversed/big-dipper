/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 * @fileoverview Implements a convenient thunk function to handle the common case
 * of creating a memoized function that takes its inputs from mutable class properties.
 */
import { MemoizedFunction } from "./index";
export declare type Thunk<R> = () => R;
export declare function memThunk<I1, O>(arg1: Thunk<I1>, compute: (this: void, arg1: I1) => O): MemoizedFunction<Thunk<O>>;
export declare function memThunk<I1, I2, O>(arg1: Thunk<I1>, arg2: Thunk<I2>, compute: (this: void, arg1: I1, arg2: I2) => O): MemoizedFunction<Thunk<O>>;
export declare function memThunk<I1, I2, I3, O>(arg1: Thunk<I1>, arg2: Thunk<I2>, arg3: Thunk<I3>, compute: (this: void, arg1: I1, arg2: I2, arg3: I3) => O): MemoizedFunction<Thunk<O>>;
export declare function memThunk<I1, I2, I3, I4, O>(arg1: Thunk<I1>, arg2: Thunk<I2>, arg3: Thunk<I3>, arg4: Thunk<I4>, compute: (this: void, arg1: I1, arg2: I2, arg3: I3, arg4: I4) => O): MemoizedFunction<Thunk<O>>;
