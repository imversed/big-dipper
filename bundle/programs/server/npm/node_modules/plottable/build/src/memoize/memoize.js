"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 * @fileoverview Implements a function memoizer using the Signature API.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var signature_1 = require("./signature");
/**
 * Return a memoized version of the input function. The memoized function
 * reduces unnecessary invocations of the input by keeping a cache of the
 * return value of compute:
 *
 * <pre>
 * function compute(a, b) { return a + b }
 * const memoizedCompute = memoize(compute);
 *
 * compute(3, 7) == 10
 * compute(3, 7) == 10 // cache hit
 * </pre>
 *
 * Cache invalidation is complicated by mutable classes (Scales and Datasets).
 * The Signature API is built to solve this issue by constructing an immutable
 * snapshot of Scales/Datasets on memoized function invocation, which is itself
 * a performance hit. Thus we introduce a "doLocked" method that momentarily
 * bypasses sign/comparison logic and simply returns the cached value.
 *
 * See the Signature API for more information.
 *
 * @param {F} compute
 * @returns {MemoizedFunction<F extends Function>}
 */
function memoize(compute) {
    var lastSignature = undefined;
    var lastValue;
    var locked = false;
    var logPerformance = false;
    var memoizeFn = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (locked) {
            return lastValue;
        }
        var inputSignature = signature_1.signArray(args);
        if (lastSignature === undefined
            || lastSignature.isDifferent(inputSignature)) {
            if (logPerformance) {
                console.warn("cache miss! computing");
            }
            lastSignature = inputSignature;
            lastValue = compute.apply(this, args);
        }
        else {
            if (logPerformance) {
                console.warn("cache hit!");
            }
        }
        return lastValue;
    };
    memoizeFn.doLocked = function (cb) {
        if (locked) {
            throw new Error("Locking an already locked memoize function!");
        }
        locked = true;
        var retVal = cb.apply(this);
        locked = false;
        return retVal;
    };
    memoizeFn.logPerformance = function (log) {
        if (log === void 0) { log = true; }
        logPerformance = log;
        return this;
    };
    return memoizeFn;
}
exports.memoize = memoize;
