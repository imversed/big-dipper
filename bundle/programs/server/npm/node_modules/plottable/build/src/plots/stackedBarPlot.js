"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Typesettable = require("typesettable");
var formatters_1 = require("../core/formatters");
var memoize_1 = require("../memoize");
var Utils = require("../utils");
var barPlot_1 = require("./barPlot");
var plot_1 = require("./plot");
var StackedBar = /** @class */ (function (_super) {
    tslib_1.__extends(StackedBar, _super);
    /**
     * A StackedBar Plot stacks bars across Datasets based on the primary value of the bars.
     *   On a vertical StackedBar Plot, the bars with the same X value are stacked.
     *   On a horizontal StackedBar Plot, the bars with the same Y value are stacked.
     *
     * @constructor
     * @param {Scale} xScale
     * @param {Scale} yScale
     * @param {string} [orientation="vertical"] One of "vertical"/"horizontal".
     */
    function StackedBar(orientation) {
        if (orientation === void 0) { orientation = "vertical"; }
        var _this = _super.call(this, orientation) || this;
        _this._extremaFormatter = formatters_1.identity();
        _this._stackingResult = memoize_1.memThunk(function () { return _this.datasets(); }, function () { return _this.position().accessor; }, function () { return _this.length().accessor; }, function () { return _this._stackingOrder; }, function (datasets, positionAccessor, lengthAccessor, stackingOrder) {
            return Utils.Stacking.stack(datasets, positionAccessor, lengthAccessor, stackingOrder);
        });
        _this._stackedExtent = memoize_1.memThunk(_this._stackingResult, function () { return _this.position().accessor; }, function () { return _this._filterForProperty(_this._isVertical ? "y" : "x"); }, function (stackingResult, positionAccessor, filter) {
            return Utils.Stacking.stackedExtent(stackingResult, positionAccessor, filter);
        });
        _this.addClass("stacked-bar-plot");
        _this._stackingOrder = "bottomup";
        return _this;
    }
    StackedBar.prototype.stackingOrder = function (stackingOrder) {
        if (stackingOrder == null) {
            return this._stackingOrder;
        }
        this._stackingOrder = stackingOrder;
        this._onDatasetUpdate();
        return this;
    };
    StackedBar.prototype.extremaFormatter = function (formatter) {
        if (arguments.length === 0) {
            return this._extremaFormatter;
        }
        else {
            this._extremaFormatter = formatter;
            this.render();
            return this;
        }
    };
    StackedBar.prototype.labelFontSize = function (fontSize) {
        if (fontSize == null) {
            return _super.prototype.labelFontSize.call(this);
        }
        else {
            if (this._labelArea != null) {
                // clearing to remove outdated font-size classes
                this._labelArea.attr("class", null)
                    .classed(barPlot_1.Bar._LABEL_AREA_CLASS, true)
                    .classed("label-" + this._labelFontSize, true);
            }
            _super.prototype.labelFontSize.call(this, fontSize);
            return this;
        }
    };
    StackedBar.prototype._setup = function () {
        _super.prototype._setup.call(this);
        this._labelArea = this._renderArea
            .append("g")
            .classed(barPlot_1.Bar._LABEL_AREA_CLASS, true)
            .classed("label-" + this._labelFontSize, true);
        var context = new Typesettable.SvgContext(this._labelArea.node());
        this._measurer = new Typesettable.CacheMeasurer(context);
        this._writer = new Typesettable.Writer(this._measurer, context);
    };
    StackedBar.prototype._drawLabels = function () {
        var _this = this;
        _super.prototype._drawLabels.call(this);
        // remove all current labels before redrawing
        this._labelArea.selectAll("g").remove();
        var baselineValue = +this.baselineValue();
        var positionScale = this.position().scale;
        var lengthScale = this.length().scale;
        var _a = Utils.Stacking.stackedExtents(this._stackingResult()), maximumExtents = _a.maximumExtents, minimumExtents = _a.minimumExtents;
        var anyTooWide = [];
        /**
         * Try drawing the text at the center of the bounds. This method does not draw
         * the text if the text would overflow outside of the plot.
         *
         * @param text
         * @param bounds
         * @returns {boolean}
         */
        var maybeDrawLabel = function (text, bounds, barThickness) {
            var _a = bounds.topLeft, x = _a.x, y = _a.y;
            var width = bounds.bottomRight.x - bounds.topLeft.x;
            var height = bounds.bottomRight.y - bounds.topLeft.y;
            var textTooLong = _this._isVertical
                ? width > barThickness
                : height > barThickness;
            if (!textTooLong) {
                var labelContainer = _this._labelArea.append("g").attr("transform", "translate(" + x + ", " + y + ")");
                labelContainer.classed("stacked-bar-label", true);
                var writeOptions = {
                    xAlign: "center",
                    yAlign: "center",
                };
                _this._writer.write(text, width, height, writeOptions, labelContainer.node());
            }
            return textTooLong;
        };
        var drawLabelsForExtents = function (stacks, computeLabelTopLeft) {
            var attrToProjector = _this._generateAttrToProjector();
            var plotWidth = _this.width();
            var plotHeight = _this.height();
            stacks.forEach(function (stack) {
                if (stack.extent !== baselineValue) {
                    // only draw sums for values not at the baseline
                    var text = _this.extremaFormatter()(stack.extent);
                    var textDimensions = _this._measurer.measure(text);
                    var stackedDatum = stack.stackedDatum;
                    var originalDatum = stackedDatum.originalDatum, originalIndex = stackedDatum.originalIndex, originalDataset = stackedDatum.originalDataset;
                    // only consider stack extents that are on the screen
                    if (!_this._isDatumOnScreen(attrToProjector, plotWidth, plotHeight, originalDatum, originalIndex, originalDataset)) {
                        return;
                    }
                    var barThickness = plot_1.Plot._scaledAccessor(_this.attr(barPlot_1.Bar._BAR_THICKNESS_KEY))(originalDatum, originalIndex, originalDataset);
                    /*
                     * The stackEdge is aligned at the edge of the stack in the length dimension,
                     * and in the center of the stack in the thickness dimension.
                     */
                    var stackEdgeLength = lengthScale.scale(stack.extent);
                    var stackCenterPosition = _this._getPositionAttr(positionScale.scale(stack.axisValue), barThickness) + barThickness / 2;
                    var stackEdge = _this._isVertical
                        ? {
                            x: stackCenterPosition,
                            y: stackEdgeLength,
                        }
                        : {
                            x: stackEdgeLength,
                            y: stackCenterPosition,
                        };
                    var topLeft = computeLabelTopLeft(stackEdge, textDimensions, barThickness);
                    var isTooWide = maybeDrawLabel(text, {
                        topLeft: topLeft,
                        bottomRight: {
                            x: topLeft.x + textDimensions.width,
                            y: topLeft.y + textDimensions.height,
                        },
                    }, barThickness);
                    anyTooWide.push(isTooWide);
                }
            });
        };
        drawLabelsForExtents(maximumExtents, function (stackEdge, measurement, thickness) {
            var primaryTextMeasurement = _this._isVertical ? measurement.width : measurement.height;
            var secondaryTextMeasurement = _this._isVertical ? measurement.height : measurement.width;
            return {
                x: _this._isVertical
                    ? stackEdge.x - primaryTextMeasurement / 2
                    : stackEdge.x + StackedBar._EXTREMA_LABEL_MARGIN_FROM_BAR,
                y: _this._isVertical
                    ? stackEdge.y - secondaryTextMeasurement
                    : stackEdge.y - primaryTextMeasurement / 2,
            };
        });
        drawLabelsForExtents(minimumExtents, function (stackEdge, measurement, thickness) {
            var primaryTextMeasurement = _this._isVertical ? measurement.width : measurement.height;
            var secondaryTextMeasurement = _this._isVertical ? measurement.height : measurement.width;
            return {
                x: _this._isVertical
                    ? stackEdge.x - primaryTextMeasurement / 2
                    : stackEdge.x - secondaryTextMeasurement,
                y: _this._isVertical
                    ? stackEdge.y + StackedBar._EXTREMA_LABEL_MARGIN_FROM_BAR
                    : stackEdge.y - primaryTextMeasurement / 2,
            };
        });
        if (anyTooWide.some(function (d) { return d; })) {
            this._labelArea.selectAll("g").remove();
        }
    };
    StackedBar.prototype._generateAttrToProjector = function () {
        var _this = this;
        var attrToProjector = _super.prototype._generateAttrToProjector.call(this);
        var valueAttr = this._isVertical ? "y" : "x";
        var lengthScale = this.length().scale;
        var lengthAccessor = this.length().accessor;
        var positionAccessor = this.position().accessor;
        var normalizedPositionAccessor = function (datum, index, dataset) {
            return Utils.Stacking.normalizeKey(positionAccessor(datum, index, dataset));
        };
        var stackingResult = this._stackingResult();
        var getStart = function (d, i, dataset) {
            return lengthScale.scale(stackingResult.get(dataset).get(normalizedPositionAccessor(d, i, dataset)).offset);
        };
        var getEnd = function (d, i, dataset) {
            return lengthScale.scale(+lengthAccessor(d, i, dataset) +
                stackingResult.get(dataset).get(normalizedPositionAccessor(d, i, dataset)).offset);
        };
        var heightF = function (d, i, dataset) {
            return Math.abs(getEnd(d, i, dataset) - getStart(d, i, dataset));
        };
        attrToProjector[this._isVertical ? "height" : "width"] = heightF;
        var attrFunction = function (d, i, dataset) {
            return +lengthAccessor(d, i, dataset) < 0 ? getStart(d, i, dataset) : getEnd(d, i, dataset);
        };
        attrToProjector[valueAttr] = function (d, i, dataset) {
            return _this._isVertical ? attrFunction(d, i, dataset) : attrFunction(d, i, dataset) - heightF(d, i, dataset);
        };
        return attrToProjector;
    };
    StackedBar.prototype.getExtentsForProperty = function (attr) {
        var primaryAttr = this._isVertical ? "y" : "x";
        if (attr === primaryAttr) {
            return [this._stackedExtent()];
        }
        else {
            return _super.prototype.getExtentsForProperty.call(this, attr);
        }
    };
    StackedBar.prototype.invalidateCache = function () {
        _super.prototype.invalidateCache.call(this);
        if (this._measurer != null) {
            this._measurer.reset();
        }
    };
    StackedBar._EXTREMA_LABEL_MARGIN_FROM_BAR = 5;
    return StackedBar;
}(barPlot_1.Bar));
exports.StackedBar = StackedBar;
