"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 * @fileoverview Implements the Signature API to help in comparing when two
 * Plottable objects have "changed".
 *
 * Memoization in Plottable is complicated by mutable scales and datasets. We cannot simply
 * reference compare two e.g. scales since it may have internally mutated. To resolve this,
 * we write a recursive Signature interface that holds an immutable snapshot of whatever
 * state the scale/data was in at the time. Then on memoized function invocation we sign the
 * new inputs and compare the signatures to decide if we should recompute.
 *
 * We must hand-write a signature for each custom class we wish to support.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var isPlainObject = require("is-plain-object");
var dataset_1 = require("../core/dataset");
var scale_1 = require("../scales/scale");
/**
 * Generic signature factory - pass any value and get a signature for it.
 *
 * Datasets and Scales are handled specially - see their respective signing methods.
 *
 * If the input is already a signature, simply return it.
 *
 * @param a
 * @returns {Signature}
 */
function sign(a) {
    if (a instanceof Signature) {
        return a;
    }
    else if (a instanceof Date) {
        return signRef(a.valueOf());
    }
    else if (a instanceof scale_1.Scale) {
        return signScale(a);
    }
    else if (a instanceof dataset_1.Dataset) {
        return signDataset(a);
    }
    else if (isPlainObject(a)) {
        return signObj(a);
    }
    else if (Array.isArray(a)) {
        return signArray(a);
    }
    else {
        return signRef(a);
    }
}
exports.sign = sign;
function signScale(scale) {
    var scaleObj = {
        // required in case the domain has changed without the updateId changing
        domain: scale.domain(),
        // required in case the range has changed without the updateId changing
        range: scale.range(),
        // generic catch-all for scale updates (existing code doesn't fully catch all
        // updates, but it's good for something)
        updateId: scale.updateId(),
        // keep a ref to the scale in case the ref changes
        ref: signRef(scale),
    };
    return signObj(scaleObj);
}
exports.signScale = signScale;
function signDataset(dataset) {
    var datasetObj = {
        ref: signRef(dataset),
        // only sign updateId since only data() and metadata() exist as properties
        // and both update updateId
        updateId: dataset.updateId(),
    };
    return signObj(datasetObj);
}
exports.signDataset = signDataset;
function signRef(a) {
    return new ReferenceSignature(a);
}
exports.signRef = signRef;
function signArray(a) {
    return new ArraySignature(a.map(function (element) { return sign(element); }));
}
exports.signArray = signArray;
function signObj(obj) {
    var signatureRecord = {};
    for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
            signatureRecord[key] = sign(obj[key]);
        }
    }
    return new ObjectSignature(signatureRecord);
}
exports.signObj = signObj;
/**
 * Base signature. Subclasses should implement isSignatureDifferent. All classes
 * should be immutable.
 *
 * Users should only call `isDifferent`, not `isSignatureDifferent`.
 */
var Signature = /** @class */ (function () {
    function Signature() {
    }
    Signature.prototype.isDifferent = function (other) {
        if (other instanceof this.constructor) {
            return this.isSignatureDifferent(other);
        }
        else {
            return true;
        }
    };
    return Signature;
}());
exports.Signature = Signature;
/**
 * A signature for an array.
 */
var ArraySignature = /** @class */ (function (_super) {
    tslib_1.__extends(ArraySignature, _super);
    function ArraySignature(array) {
        var _this = _super.call(this) || this;
        _this.array = array;
        return _this;
    }
    /**
     * An array of signatures is different if any of the elements isDifferent.
     */
    ArraySignature.prototype.isSignatureDifferent = function (other) {
        if (other.array.length !== this.array.length) {
            return true;
        }
        else {
            for (var i = 0; i < this.array.length; i++) {
                if (this.array[i].isDifferent(other.array[i])) {
                    return true;
                }
            }
            return false;
        }
    };
    return ArraySignature;
}(Signature));
exports.ArraySignature = ArraySignature;
var ReferenceSignature = /** @class */ (function (_super) {
    tslib_1.__extends(ReferenceSignature, _super);
    function ReferenceSignature(ref) {
        var _this = _super.call(this) || this;
        _this.ref = ref;
        return _this;
    }
    ReferenceSignature.prototype.isSignatureDifferent = function (other) {
        return this.ref !== other.ref;
    };
    return ReferenceSignature;
}(Signature));
exports.ReferenceSignature = ReferenceSignature;
/**
 * A signature for a plain js object.
 */
var ObjectSignature = /** @class */ (function (_super) {
    tslib_1.__extends(ObjectSignature, _super);
    function ObjectSignature(obj) {
        var _this = _super.call(this) || this;
        _this.obj = obj;
        return _this;
    }
    /**
     * An object signature is different if any of the elements isDifferent.
     */
    ObjectSignature.prototype.isSignatureDifferent = function (other) {
        var myKeys = Object.keys(this.obj);
        var otherKeys = Object.keys(other.obj);
        if (myKeys.length !== otherKeys.length) {
            return true;
        }
        for (var _i = 0, myKeys_1 = myKeys; _i < myKeys_1.length; _i++) {
            var key = myKeys_1[_i];
            if (!other.obj.hasOwnProperty(key)) {
                return true;
            }
            if (this.obj[key].isDifferent(other.obj[key])) {
                return true;
            }
        }
        return false;
    };
    return ObjectSignature;
}(Signature));
exports.ObjectSignature = ObjectSignature;
