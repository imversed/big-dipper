"use strict";
/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
var d3 = require("d3");
var domUtils_1 = require("./domUtils");
var nativeMath = window.Math;
var _IDENTITY_TRANSFORM = [1, 0, 0, 1, 0, 0];
/**
 * Checks if x is between a and b.
 *
 * @param {number} x The value to test if in range
 * @param {number} a The beginning of the (inclusive) range
 * @param {number} b The ending of the (inclusive) range
 * @return {boolean} Whether x is in [a, b]
 */
function inRange(x, a, b) {
    return (nativeMath.min(a, b) <= x && x <= nativeMath.max(a, b));
}
exports.inRange = inRange;
/**
 * Clamps x to the range [min, max].
 *
 * @param {number} x The value to be clamped.
 * @param {number} min The minimum value.
 * @param {number} max The maximum value.
 * @return {number} A clamped value in the range [min, max].
 */
function clamp(x, min, max) {
    return nativeMath.min(nativeMath.max(min, x), max);
}
exports.clamp = clamp;
function max(array, firstArg, secondArg) {
    var accessor = typeof (firstArg) === "function" ? firstArg : null;
    var defaultValue = accessor == null ? firstArg : secondArg;
    var maxValue = accessor == null ? d3.max(array) : d3.max(array, accessor);
    return maxValue !== undefined ? maxValue : defaultValue;
}
exports.max = max;
function min(array, firstArg, secondArg) {
    var accessor = typeof (firstArg) === "function" ? firstArg : null;
    var defaultValue = accessor == null ? firstArg : secondArg;
    var minValue = accessor == null ? d3.min(array) : d3.min(array, accessor);
    return minValue !== undefined ? minValue : defaultValue;
}
exports.min = min;
/**
 * Returns true **only** if x is NaN
 */
function isNaN(n) {
    return n !== n;
}
exports.isNaN = isNaN;
/**
 * Returns true if the argument is a number, which is not NaN
 * Numbers represented as strings do not pass this function
 */
function isValidNumber(n) {
    return typeof n === "number" && n - n < 1;
}
exports.isValidNumber = isValidNumber;
/**
 * Generates an array of consecutive, strictly increasing numbers
 * in the range [start, stop) separeted by step
 */
function range(start, stop, step) {
    if (step === void 0) { step = 1; }
    if (step === 0) {
        throw new Error("step cannot be 0");
    }
    var length = nativeMath.max(nativeMath.ceil((stop - start) / step), 0);
    var range = [];
    for (var i = 0; i < length; ++i) {
        range[i] = start + step * i;
    }
    return range;
}
exports.range = range;
/**
 * Returns the square of the distance between two points
 *
 * @param {Point} p1
 * @param {Point} p2
 * @return {number} dist(p1, p2)^2
 */
function distanceSquared(p1, p2) {
    return nativeMath.pow(p2.y - p1.y, 2) + nativeMath.pow(p2.x - p1.x, 2);
}
exports.distanceSquared = distanceSquared;
function degreesToRadians(degree) {
    return degree / 360 * nativeMath.PI * 2;
}
exports.degreesToRadians = degreesToRadians;
/**
 * Returns if the point is within the bounds. Points along
 * the bounds are considered "within" as well.
 * @param {Point} p Point in considerations.
 * @param {Bounds} bounds Bounds within which to check for inclusion.
 */
function within(p, bounds) {
    return bounds.topLeft.x <= p.x
        && bounds.bottomRight.x >= p.x
        && bounds.topLeft.y <= p.y
        && bounds.bottomRight.y >= p.y;
}
exports.within = within;
/**
 * Returns whether the first bounds intersects the second bounds.
 * Pass primitive numbers directly for performance.
 *
 * Assumes width and heights are positive.
 */
function boundsIntersects(aX, aY, aWidth, aHeight, bX, bY, bWidth, bHeight) {
    return aX <= bX + bWidth &&
        bX <= aX + aWidth &&
        aY <= bY + bHeight &&
        bY <= aY + aHeight;
}
exports.boundsIntersects = boundsIntersects;
/**
 * Returns a `ICssTransformMatrix` representing the cumulative transformation of
 * the element and all its parents. This transform converts from top-level
 * clientX/clientY coordinates (such as document mouse events) to internal
 * component offsetX/offsetY coordinates.
 *
 * Use `applyTransform` to convert from client coordinates to element
 * coordinates, accounting for all CSS transforms applied to that element.
 *
 * Note that this handles css `transform` but does not handle css
 * `transform-origin` values other than default ("50% 50%").
 */
function getCumulativeTransform(element) {
    var elems = domUtils_1.getHtmlElementAncestors(element);
    var transform = _IDENTITY_TRANSFORM;
    var offsetParent = null;
    for (var _i = 0, elems_1 = elems; _i < elems_1.length; _i++) {
        var elem = elems_1[_i];
        // apply css transform from any ancestor element
        var elementTransform = domUtils_1.getElementTransform(elem);
        if (elementTransform != null) {
            var midX = elem.clientWidth / 2;
            var midY = elem.clientHeight / 2;
            transform = multiplyTranslate(transform, [midX, midY]);
            transform = multiplyMatrix(transform, invertMatrix(elementTransform));
            transform = multiplyTranslate(transform, [-midX, -midY]);
        }
        // apply scroll offsets from any ancestor element
        var offsetX = elem.scrollLeft;
        var offsetY = elem.scrollTop;
        // apply client+offset from only acenstor "offsetParent"
        if (offsetParent === null || elem === offsetParent) {
            offsetX -= elem.offsetLeft + elem.clientLeft;
            offsetY -= elem.offsetTop + elem.clientTop;
            offsetParent = elem.offsetParent;
        }
        transform = multiplyTranslate(transform, [offsetX, offsetY]);
    }
    return transform;
}
exports.getCumulativeTransform = getCumulativeTransform;
/**
 * Straightforward matrix multiplication of homogenized css transform matrices.
 */
function multiplyMatrix(a, b) {
    return [
        a[0] * b[0] + a[2] * b[1],
        a[1] * b[0] + a[3] * b[1],
        a[0] * b[2] + a[2] * b[3],
        a[1] * b[2] + a[3] * b[3],
        a[0] * b[4] + a[2] * b[5] + a[4],
        a[1] * b[4] + a[3] * b[5] + a[5],
    ];
}
exports.multiplyMatrix = multiplyMatrix;
/**
 * Prepends translation to transformation matrix.
 *
 * Equivalent to `multiplyMatrix([1, 0, 0, 1, ...v], b)`
 */
function premultiplyTranslate(v, b) {
    return [
        b[0], b[1], b[2], b[3],
        b[4] + v[0],
        b[5] + v[1],
    ];
}
exports.premultiplyTranslate = premultiplyTranslate;
/**
 * Appends translation to transformation matrix.
 *
 * Equivalent to `multiplyMatrix(a, [1, 0, 0, 1, ...v])`
 */
function multiplyTranslate(a, v) {
    return [
        a[0], a[1], a[2], a[3],
        a[0] * v[0] + a[2] * v[1] + a[4],
        a[1] * v[0] + a[3] * v[1] + a[5],
    ];
}
exports.multiplyTranslate = multiplyTranslate;
/**
 * Analytical inverse of a `ICssTransformMatrix` analogous to a non-singular
 * homogenous 3x3 matrix.
 *
 * http://mathworld.wolfram.com/MatrixInverse.html
 * https://stackoverflow.com/questions/2624422/efficient-4x4-matrix-inverse-affine-transform
 */
function invertMatrix(a) {
    var determinant = a[0] * a[3] - a[1] * a[2];
    if (determinant === 0) {
        throw new Error("singular matrix");
    }
    var inverseDeterminant = 1 / determinant;
    return [
        inverseDeterminant * a[3],
        inverseDeterminant * -a[1],
        inverseDeterminant * -a[2],
        inverseDeterminant * a[0],
        inverseDeterminant * (-a[3] * a[4] + a[2] * a[5]),
        inverseDeterminant * (a[1] * a[4] + -a[0] * a[5]),
    ];
}
exports.invertMatrix = invertMatrix;
/**
 * Applies the `ICssTransformMatrix` to the `Point`.
 *
 * Returns a new `Point`.
 */
function applyTransform(a, p) {
    return {
        x: a[0] * p.x + a[2] * p.y + a[4],
        y: a[1] * p.x + a[3] * p.y + a[5],
    };
}
exports.applyTransform = applyTransform;
