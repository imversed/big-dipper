import { Dataset } from "../core/dataset";
import { Scale } from "../scales/scale";
/**
 * Generic signature factory - pass any value and get a signature for it.
 *
 * Datasets and Scales are handled specially - see their respective signing methods.
 *
 * If the input is already a signature, simply return it.
 *
 * @param a
 * @returns {Signature}
 */
export declare function sign(a: any): Signature;
export declare function signScale(scale: Scale<any, any>): ObjectSignature;
export declare function signDataset(dataset: Dataset): ObjectSignature;
export declare function signRef(a: any): ReferenceSignature;
export declare function signArray(a: any[]): ArraySignature;
export declare function signObj(obj: {
    [key: string]: any;
}): ObjectSignature;
/**
 * Base signature. Subclasses should implement isSignatureDifferent. All classes
 * should be immutable.
 *
 * Users should only call `isDifferent`, not `isSignatureDifferent`.
 */
export declare abstract class Signature {
    isDifferent(other: Signature): boolean;
    protected abstract isSignatureDifferent(other: this): boolean;
}
/**
 * A signature for an array.
 */
export declare class ArraySignature extends Signature {
    private array;
    constructor(array: Signature[]);
    /**
     * An array of signatures is different if any of the elements isDifferent.
     */
    isSignatureDifferent(other: ArraySignature): boolean;
}
export declare class ReferenceSignature extends Signature {
    private ref;
    constructor(ref: any);
    isSignatureDifferent(other: ReferenceSignature): boolean;
}
export declare type ISignatureRecord = Record<string, Signature>;
/**
 * A signature for a plain js object.
 */
export declare class ObjectSignature extends Signature {
    private obj;
    constructor(obj: ISignatureRecord);
    /**
     * An object signature is different if any of the elements isDifferent.
     */
    isSignatureDifferent(other: ObjectSignature): boolean;
}
